{"name":"Webp-ffi","tagline":"Ruby wrapper for libwebp","body":"# Webp-ffi\r\n\r\n[![Build Status](https://travis-ci.org/le0pard/webp-ffi.png)](https://travis-ci.org/le0pard/webp-ffi) \r\n[![Code Climate](https://codeclimate.com/github/le0pard/webp-ffi.png)](https://codeclimate.com/github/le0pard/webp-ffi)\r\n\r\nRuby wrapper for libwebp. What is WebP?\r\n\r\nWebP is a new image format that provides lossless and lossy compression for images on the web. WebP lossless images are 26% smaller in size compared to PNGs. WebP lossy images are 25-34% smaller in size compared to JPEG images at equivalent SSIM index. WebP supports lossless transparency (also known as alpha channel) with just 22% additional bytes. Transparency is also supported with lossy compression and typically provides 3x smaller file sizes compared to PNG when lossy compression is acceptable for the red/green/blue color channels.\r\n\r\n## [WebP Gallery](https://developers.google.com/speed/webp/gallery)\r\n\r\n## Installation\r\n\r\n### Requirements\r\n\r\nFirst of all you should have install libraries: libpng, libjpeg and libwebp (for libwebp need libpng and libjpeg).\r\n\r\nFor ubuntu, debian:\r\n\r\n    sudo apt-get install libjpeg62-dev libpng12-dev libtiff4-dev\r\n    \r\nFor Mac OS:\r\n\r\n    sudo port install jpeg libpng tiff\r\n    \r\nor:\r\n\r\n    brew install libjpg libpng libtiff\r\n    \r\nNext, you should [install libwebp](https://developers.google.com/speed/webp/docs/compiling).\r\n\r\n### Final part\r\n\r\nAdd this line to your application's Gemfile:\r\n\r\n    gem 'webp-ffi'\r\n\r\nAnd then execute:\r\n\r\n    $ bundle\r\n\r\nOr install it yourself as:\r\n\r\n    $ gem install webp-ffi\r\n\r\n## Usage\r\n\r\n### Encoder end Decoder versions\r\n\r\nBasic info about libwebp (encoder and decoder versions):\r\n\r\n    $ irb\r\n    2.0.0p0 :001 > require 'webp_ffi'\r\n     => true \r\n    2.0.0p0 :002 > WebP.decoder_version\r\n     => \"0.2.0\" \r\n    2.0.0p0 :003 > WebP.encoder_version\r\n     => \"0.2.0\"\r\n     \r\n\r\n### WebP size (width and height)\r\n     \r\nGet size (width and height) from webp image:\r\n\r\n    filename = File.expand_path(File.join(File.dirname(__FILE__), \"spec/factories/4.webp\"))\r\n    WebP.webp_size(File.open(filename, \"rb\").read)\r\n     => [2000, 2353]\r\n     \r\n    \r\n### Encode WebP image\r\n\r\nEncode png, jpg or tiff image to webp:\r\n\r\n    filename = File.expand_path(File.join(File.dirname(__FILE__), \"spec/factories/4.png\"))\r\n    out_filename = File.expand_path(File.join(File.dirname(__FILE__), \"tmp/4.webp\"))\r\n    WebP.encode(filename, out_filename)\r\n    \r\n     \r\nEncode png, jpg or tiff image to webp with options:\r\n\r\n    WebP.encode(filename, out_filename, quality: 50, resize_w: 100, resize_h: 200)\r\n    WebP.encode(filename, out_filename, quality: 75, crop_x: 0, cropt_y: 0, crop_w: 100, crop_h: 100)\r\n    \r\n    \r\nPossible encode options:\r\n\r\n * **lossless** (int) - Lossless encoding (0=lossy(default), 1=lossless)\r\n * **quality** (float) - between 0 (smallest file) and 100 (biggest)\r\n * **method** (int) - quality/speed trade-off (0=fast, 6=slower-better)\r\n * **target\\_size** (int) - if non-zero, set the desired target size in bytes. Takes precedence over the 'compression' parameter\r\n * **target\\_PSNR** (float) - if non-zero, specifies the minimal distortion to try to achieve. Takes precedence over target\\_size\r\n * **segments** (int) - maximum number of segments to use, in [1..4]\r\n * **sns_strength** (int) - Spatial Noise Shaping. 0=off, 100=maximum\r\n * **filter\\_strength** (int) - range: [0 = off .. 100 = strongest]\r\n * **filter\\_sharpness** (int) - range: [0 = off .. 7 = least sharp]\r\n * **filter\\_type** (int) - filtering type: 0 = simple, 1 = strong (only used if filter\\_strength > 0 or autofilter > 0)\r\n * **autofilter** (int) - Auto adjust filter's strength [0 = off, 1 = on]\r\n * **alpha\\_compression** (int) - Algorithm for encoding the alpha plane (0 = none, 1 = compressed with WebP lossless). Default is 1\r\n * **alpha\\_filtering** (int) - Predictive filtering method for alpha plane. 0: none, 1: fast, 2: best. Default if 1\r\n * **alpha\\_quality** (int) - Between 0 (smallest size) and 100 (lossless). Default is 100\r\n * **pass** (int) - number of entropy-analysis passes (in [1..10])\r\n * **show\\_compressed** (int) - if true, export the compressed picture back. In-loop filtering is not applied\r\n * **preprocessing** (int) - preprocessing filter (0=none, 1=segment-smooth)\r\n * **partitions** (int) - log2(number of token partitions) in [0..3]. Default is set to 0 for easier progressive decoding\r\n * **partition\\_limit** (int) - quality degradation allowed to fit the 512k limit on prediction modes coding (0: no degradation, 100: maximum possible degradation)\r\n * **width** (int), **height** (int) - Input size (width x height) for YUV\r\n * **crop\\_x** (int), **crop\\_y** (int), **crop\\_w** (int), **crop\\_h** (int) - crop picture with the given rectangle\r\n * **resize\\_w** (int), **resize\\_h** (int) - resize picture (after any cropping)\r\n \r\n### Decode WebP image\r\n\r\nDecode webp image (default format is png):\r\n\r\n    filename = File.expand_path(File.join(File.dirname(__FILE__), \"spec/factories/4.webp\"))\r\n    out_filename = File.expand_path(File.join(File.dirname(__FILE__), \"tmp/4.png\"))\r\n    WebP.decode(filename, out_filename)\r\n    \r\n    \r\nDecode webp image to pam, ppm or pgm format of image:\r\n\r\n    filename = File.expand_path(File.join(File.dirname(__FILE__), \"spec/factories/4.webp\"))\r\n    out_filename = File.expand_path(File.join(File.dirname(__FILE__), \"tmp/4.png\"))\r\n    WebP.decode(filename, out_filename, output_format: :pam)\r\n    WebP.decode(filename, out_filename, output_format: :ppm)\r\n    WebP.decode(filename, out_filename, output_format: :pgm)\r\n    \r\n    \r\nDecode webp image with options:\r\n\r\n    WebP.encode(filename, out_filename, resize_w: 100, resize_h: 200)\r\n    WebP.encode(filename, out_filename, crop_x: 0, cropt_y: 0, crop_w: 100, crop_h: 100)\r\n    \r\n    \r\nPossible decode options:\r\n\r\n * **bypass\\_filtering** (bool) - disable in-loop filtering\r\n * **no\\_fancy\\_upsampling** (bool) - don't use the fancy YUV420 upscaler\r\n * **use\\_threads** (bool) - use multi-threading\r\n * **crop\\_x** (int), **crop\\_y** (int), **crop\\_w** (int), **crop\\_h** (int) - crop picture with the given rectangle\r\n * **resize\\_w** (int), **resize\\_h** (int) - resize picture (after any cropping)\r\n\r\n## Contributing\r\n\r\n1. Fork it\r\n2. Create your feature branch (`git checkout -b my-new-feature`)\r\n3. Commit your changes (`git commit -am 'Add some feature'`)\r\n4. Push to the branch (`git push origin my-new-feature`)\r\n5. Create new Pull Request\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}